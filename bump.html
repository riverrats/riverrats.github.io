<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale=1.0">
    <title>Peter's Timeline Visual </title>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/0.19.2/axios.min.js"></script>
    <script src="https://momentjs.com/downloads/moment.js"></script>
    <script src="//d3js.org/d3.v4.min.js"></script>
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="./bump.js"></script>
        <style>
            .active {
                opacity: 1.0;
            }

            .tooltip {
                position: absolute;
                padding: 10px;
                font: 12px sans-serif;
                background: #222;
                color: #fff;
                border: 0px;
                border-radius: 8px;
                pointer-events: none;
                opacity: 0.9;
                visibility: hidden;
            }

            path.active {
                stroke-width: 3.0;
            }
        </style>
</head>
<body>
        <div class="container">
            <div class="row mt-5">
                <div class="col  d-flex flex-row justify-content-center">
                    <a class="btn btn-secondary" href="index.html"> Go home </a>
                </div>
            </div>
            <div class="row mt-5">

                <div class="d-flex flex-column justify-items-center justify-content-center">
                        <p class="text-center"> Peter's Timeline Visual (desktop might work better). A different type of line chart called a bump chart, this shows the top 10 runners throughout the history of huron. The range 2003-2019 was selected as before 2003 data is spotty.

                            Hover over a line to view more information. A black outline symbolizes an athletes last race. Sometimes the dots aren't connected properly, my bad.
                        </p>
                        <button class="btn btn-primary mt-5" onclick="generate('M')">generate Chart Guys</button>
                        <button class="btn btn-primary mt-5" onclick="generate('F')">generate Chart Girls</button>
                        <div id="status"></div>
                </div>
                <div class="col">
                </div>
            </div>

        </div>
        <svg>

        </svg>
    
    <script>
        let engine = new RunData();
        year = 2003
        function generate(gender) {
            $('#status').text('Downloading ~17 web pages (this might take a little while)...')
            let years = []
            for (let y = year; y <= 2019;y++) {
                years.push(y)
            }
            Promise.all(years.map(y => engine.getResultsGrid("13318",`${y}`,gender))).then(res => {
                            $('#status').text('Now generating data structures...')
            let allSeasons = res.reduce((obj, season) => {
            return Object.assign(obj, season)
            }, {})
            console.log(allSeasons)
            // Seperate out by athlete and only keep (1) seasonEndNode
            let flatData = Object.values(allSeasons).flatMap(d=>d)
            console.log(flatData)
            let uniqueNames = [...new Set(flatData.map(d=>d.name))]
            console.log(uniqueNames)
            for (let name of uniqueNames) {
            if (flatData.filter(d => d.name == name && d.seasonEndNode == true).length == 0) {
            console.log(name)
            console.log(flatData.filter(d => d.name == name))
            }
            let athleteData = flatData.filter(d => d.name == name && d.seasonEndNode == true).slice(-1)[0].time
            console.log(athleteData)
            let afterSeason = false
            flatData = flatData.map(d => {
            if (d.name == name && afterSeason) { d.afterSeason = true }
            if (d.seasonEndNode && d.time == athleteData) { afterSeason = true; d.careerEndNode = true }
            return d
            })
            }
            let biggestRace = Math.max(...Object.values(allSeasons).map(v => v.filter(t => t.time !== null).length))
            let dates = Object.keys(allSeasons).sort(function(a,b) {
            return moment(a.replace("(2)","")).isBefore(moment(b.replace("(2)",""))) ? -1 : 1;
            })
            // Now we check differences to find end node for each athlete. If name in season1 and not in season2,
            endNode = true
            console.log(allSeasons)
            createChart(flatData, dates, biggestRace)
            })
        }
        function createChart(flatData, dateRange, maxRace) {
            $('#status').text('Now building chart...')
            var width = 16000
            var height = 300
            var horizontalOffset = 50
            var verticalOffset = 30
            d3.selectAll("svg > *").remove();
            var svg = d3.select('svg')
            .attr('width', width)
            .attr('height', height)

            var x = d3.scaleBand() // This will be the dates
            .domain(dateRange)
            .range([horizontalOffset, width - horizontalOffset])
            .round(true) // rangeRound is shorthand
            var y = d3.scaleLinear()
            .domain([1, maxRace])
            .range([verticalOffset, height - verticalOffset]);

            var xAxis = d3.axisBottom(x)
            var yAxis = d3.axisLeft(y)
            svg.append('g')
            .attr("transform", `translate(${horizontalOffset - (x.bandwidth()/2)},${height - verticalOffset})`)
            .call(xAxis)
            svg.append('g')
            .attr("transform", `translate(${horizontalOffset},0)`)
            .call(yAxis)
            let uniqueNames = [...new Set(flatData.map(d=>d.name))]
            let colorScale = d3.scaleOrdinal(d3.schemeCategory20).domain(uniqueNames)
            //console.log(uniqueNames)
            for (let name of uniqueNames) {
                let athleteData = flatData.filter(d => d.name == name)
                // Now we add fillers
                // (0) sort in chronological order
                // athleteData.sort(function(a,b) {
                // return moment(a.date).isBefore(moment(b.date)) ? -1 : 1;
                // })
                // //console.log(athleteData)
                // // (1) find last legit time
                // let times = athleteData.map(d=>d.time)
                // let lastTime = times.slice().reverse().filter(d=>d !== null)[0] // the last legit time
                // let lastTimeIdx = times.indexOf(lastTime)
                // console.log(lastTime, times[lastTimeIdx], athleteData[lastTimeIdx].time)
                // // (2) fill in athlete data
                // for (let i=1;i<athleteData.length;i++) {
                //     if (i > lastTimeIdx) {
                //         console.log('Skipping')
                //         continue
                //     }// the rest are null, so keep them
                //     if (athleteData[i-1].time == null) { continue }
                //     if (athleteData[i].time == null) {
                //         console.log('Setting time...')
                //     athleteData[i].time = athleteData[i-1].time
                //     }
                // }
                // This will be a pain in the ass but we need to duplicate certain data values
                let dates = athleteData.map(d => d.date)
                let copy = athleteData.slice()
                copy.forEach((val, i) => {
                    if (i == copy.length - 1 || i == 0) { return }
                    let diff = dateRange.indexOf(copy[i + 1].date) - dateRange.indexOf(val.date)
                    let diff2 = dateRange.indexOf(val.date) - dateRange.indexOf(copy[i - 1].date)
                    if  (diff > 1 && diff2 == 1) {
                        let valCopy = Object.assign({}, val)
                        console.log('duplicated node', val.date)
                        valCopy.seasonEndNode = false
                        valCopy.isCopy = true
                        valCopy.actualTime = false
                        athleteData.splice(i, 0, valCopy)
                    }
                    //let prevDate = 
                })
                //console.log(athleteData)
                var lineF = d3.line()
                .x(d=>x(d.date))
                .y(d=>y(d.rank))
                .defined(d => {
                    let dates = athleteData.map(d => d.date)
                    let dateIdx = dates.indexOf(d.date)
                    //if (dateIdx == 0) { dateIdx++ }
                    if (dateIdx == dates.length - 1) {
                        return true
                    }
                    let nextDate = dates[dateIdx + 1]
                    let distanceAfter = dateRange.indexOf(nextDate) - dateRange.indexOf(dates[dateIdx])
                    if (distanceAfter == 1) { return true } else if (distanceAfter == 0) {
                        //let prevDate = dates[dateIdx - 1]
                        if (athleteData[dateIdx].isCopy) {
                            console.log('found a duplicated node', dates[dateIdx])
                            athleteData[dateIdx].isCopy = false
                            return true
                        } else { 
                            return false
                        }
                        //console.log(athleteData[dateIdx - 1], athleteData[dateIdx], athleteData[dateIdx + 1])
                        //return false
                    }

                }) // stop line when the end of the season approaches
                //var filteredData = athleteData.filter(d=>lineF.defined(d));
                //svg.append('path').attr('stroke','red').attr('fill', 'none').attr('d', lineF(filteredData));
                svg.append('g')
                .attr("transform", `translate(${horizontalOffset},0)`)
                .append("path")
                .datum(athleteData)
                .attr("d", lineF)
                .attr('fill', 'none')
                .attr('class', d=>d[0].name.replace(/\s/g,'-'))
                .attr("stroke-linejoin", "round")
                .attr("stroke-linecap", "round")
                .attr("stroke-width", '1')
                .attr('stroke', 'black')

            }
              var node = svg.append("g")
            .attr("transform", `translate(${horizontalOffset},0)`)
              .selectAll("circle")
              .data(flatData)
              .enter().append("circle")
              .attr("cx", d=>x(d.date))
              .attr("cy", d=>y(d.rank))
              .attr('class', d=>d.name.replace(/\s/g,'-'))
              .attr('fill', d=>colorScale(d.name))
              .attr("r", d=> d.time === null  ? 0 : 6)
              .attr("stroke-width", 1.5)
              .attr('stroke', d=> d.careerEndNode ? 'black' : 'white')
              .attr('opacity', d=> d.careerEndNode ? '1' : '0.3');
            // for (athlete of data.lines) {
            //     // var line = d3.line()
            //     // .x(d => x(d.date))
            //     // .y(d => {
            //     //     if (d['time'] == null) {
            //     //         console.log('null time')
            //     //         return 0;
            //     //     }
            //     //     data.lines.map(year => year.d.time
            //     // })
            //     svg.append('path')
            // }
            // For each athlete, we need a seperate line
              var tooltip = d3.select("body").append("div")
              .attr("class", "tooltip");
              svg.selectAll("circle")
      .on("mouseover", function(d) {
        svg.selectAll(`.${d.name.replace(/\s/g,'-')}`)
            .classed('active', true);

        var tooltip_str = `Name: ${d.name}<br/>Time: ${d.time}`

        tooltip.html(tooltip_str)
            .style("visibility", "visible");
      })
      .on("mousemove", function(d) {
        tooltip.style("top", event.pageY - (tooltip.node().clientHeight + 5) + "px")
            .style("left", event.pageX - (tooltip.node().clientWidth / 2.0) + "px");
      })
      .on("mouseout", function(d) {
        svg.selectAll(`.${d.name.replace(/\s/g,'-')}`)
            .classed('active', false);

        tooltip.style("visibility", "hidden");
      })
      .on('click', function(d) {
        svg.selectAll(`.${d.name.replace(/\s/g,'-')}`)
            .classed('click-active', function(d) {
              // toggle state
              return !d3.select(this).classed('click-active');
            });
      })
                  $('#status').text('Done.')
        }
    </script>

</body>
</html>